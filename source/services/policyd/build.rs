// Build scripts are allowed to panic on misconfiguration.
#![allow(clippy::expect_used)]

use std::collections::{BTreeMap, BTreeSet};
use std::env;
use std::fs;
use std::path::{Path, PathBuf};

use serde::Deserialize;

#[derive(Debug, Default, Deserialize)]
struct RawPolicy {
    #[serde(default)]
    allow: BTreeMap<String, Vec<String>>,
}

fn main() {
    println!("cargo::rustc-check-cfg=cfg(nexus_env, values(\"os\",\"host\"))");

    let manifest_dir = env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR missing");
    let policy_dir = Path::new(&manifest_dir)
        .join("../../../recipes/policy")
        .canonicalize()
        .expect("failed to resolve recipes/policy");

    let policy = load_policy_dir(&policy_dir);
    emit_policy_table(&policy);
}

fn load_policy_dir(dir: &Path) -> BTreeMap<String, BTreeSet<String>> {
    let mut files = Vec::new();
    let entries = fs::read_dir(dir).expect("failed to read recipes/policy");
    for entry in entries {
        let entry = entry.expect("failed to read policy entry");
        let path = entry.path();
        if !path.is_file() || path.extension().and_then(|s| s.to_str()) != Some("toml") {
            continue;
        }
        files.push(path);
    }
    files.sort();
    for file in &files {
        println!("cargo::rerun-if-changed={}", file.display());
    }

    let mut merged: BTreeMap<String, BTreeSet<String>> = BTreeMap::new();
    for path in files {
        let data = fs::read_to_string(&path).expect("failed to read policy file");
        let parsed: RawPolicy =
            toml::from_str(&data).unwrap_or_else(|_| panic!("failed to parse {}", path.display()));
        for (service, caps) in parsed.allow {
            let service_key = canonical(&service);
            let mut set = BTreeSet::new();
            for cap in caps {
                set.insert(canonical(&cap));
            }
            merged.insert(service_key, set);
        }
    }
    merged
}

fn emit_policy_table(policy: &BTreeMap<String, BTreeSet<String>>) {
    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR missing"));
    let dest = out_dir.join("policy_table.rs");
    let mut out = String::new();
    out.push_str("// AUTO-GENERATED by policyd/build.rs. DO NOT EDIT.\n");
    out.push_str("use nexus_sel::PolicyEntry;\n\n");
    out.push_str("pub const POLICY_ENTRIES: &[PolicyEntry] = &[\n");
    for (service, caps) in policy {
        let service_id = service_id_from_name(service.as_bytes());
        out.push_str(&format!(
            "    PolicyEntry {{ service_id: 0x{service_id:016x}u64, capabilities: &["
        ));
        let mut first = true;
        for cap in caps {
            if !first {
                out.push_str(", ");
            }
            first = false;
            out.push('"');
            out.push_str(cap);
            out.push('"');
        }
        out.push_str("] },\n");
    }
    out.push_str("];\n");
    fs::write(&dest, out).expect("failed to write policy_table.rs");
}

fn canonical(input: &str) -> String {
    input.trim().to_ascii_lowercase()
}

fn service_id_from_name(name: &[u8]) -> u64 {
    let mut h: u64 = 0xcbf29ce484222325u64;
    for &b in name {
        h ^= b as u64;
        h = h.wrapping_mul(0x100000001b3u64);
    }
    h
}
