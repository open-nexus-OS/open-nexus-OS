use nexus_loader::{load_with, parse_elf64_riscv, Error, Mapper, Prot};

const HELLO_ELF: [u8; 527] = [
    0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xf3, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x68, 0x65, 0x6c, 0x6c,
    0x6f, 0x20, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x72, 0x21, 0x21, 0x21,
];

fn fixture() -> Vec<u8> {
    HELLO_ELF.to_vec()
}

#[derive(Default)]
struct RecordingMapper {
    calls: Vec<(u64, Prot, usize, Vec<u8>)>,
}

impl Mapper for RecordingMapper {
    fn map_segment(&mut self, seg: &nexus_loader::SegmentPlan, src: &[u8]) -> Result<(), Error> {
        self.calls
            .push((seg.vaddr, seg.prot, src.len(), src.to_vec()));
        Ok(())
    }
}

#[test]
fn parse_and_load_minimal_fixture() {
    let bytes = fixture();
    let plan = parse_elf64_riscv(&bytes).expect("plan");
    assert_eq!(plan.entry, 0x10000);
    assert_eq!(plan.segments.len(), 2);

    let seg0 = &plan.segments[0];
    assert_eq!(seg0.vaddr, 0x10000);
    assert_eq!(seg0.memsz, 0x20);
    assert_eq!(seg0.filesz, 0x20);
    assert_eq!(seg0.prot, Prot::R | Prot::X);

    let seg1 = &plan.segments[1];
    assert_eq!(seg1.vaddr, 0x20000);
    assert_eq!(seg1.memsz, 0x18);
    assert_eq!(seg1.filesz, 0x10);
    assert_eq!(seg1.prot, Prot::R | Prot::W);

    let mut mapper = RecordingMapper::default();
    let plan_again = load_with(&bytes, &mut mapper).expect("load succeeds");
    assert_eq!(plan_again, plan);
    assert_eq!(mapper.calls.len(), 2);
    assert_eq!(mapper.calls[0].0, seg0.vaddr);
    assert_eq!(mapper.calls[0].1, seg0.prot);
    assert_eq!(mapper.calls[0].2, seg0.filesz as usize);
    assert_eq!(mapper.calls[1].0, seg1.vaddr);
    assert_eq!(mapper.calls[1].1, seg1.prot);
    assert_eq!(mapper.calls[1].2, seg1.filesz as usize);
    assert_eq!(mapper.calls[1].3.len(), seg1.filesz as usize);
}

#[test]
fn rejects_wx_segments() {
    let mut bytes = fixture();
    // First program header flags at offset 0x40 + 4.
    let flags_offset = 0x40 + 4;
    bytes[flags_offset..flags_offset + 4].copy_from_slice(&7u32.to_le_bytes());
    let err = parse_elf64_riscv(&bytes).expect_err("w^x rejected");
    assert!(matches!(err, Error::ProtWx));
}

#[test]
fn rejects_unaligned_segments() {
    let mut bytes = fixture();
    // Adjust first PT_LOAD p_vaddr (offset 0x40 + 16) to a non page-aligned value.
    let vaddr_offset = 0x40 + 16;
    bytes[vaddr_offset..vaddr_offset + 8].copy_from_slice(&0x10008u64.to_le_bytes());
    let err = parse_elf64_riscv(&bytes).expect_err("alignment enforced");
    assert!(matches!(err, Error::Align));
}

#[test]
fn rejects_filesz_over_memsz() {
    let mut bytes = fixture();
    // Second program header begins at 0x40 + 56.
    let second_offset = 0x40 + 56;
    let filesz_offset = second_offset + 32; // p_filesz field
    bytes[filesz_offset..filesz_offset + 8].copy_from_slice(&0x20u64.to_le_bytes());
    let err = parse_elf64_riscv(&bytes).expect_err("filesz > memsz");
    assert!(matches!(err, Error::InvalidElf(_)));
}

#[test]
fn rejects_truncated_image() {
    let bytes = fixture();
    let truncated = &bytes[..80];
    let err = parse_elf64_riscv(truncated).expect_err("truncated image");
    assert!(matches!(err, Error::Truncated));
}

#[test]
fn rejects_non_pt_load_segments() {
    let mut bytes = fixture();
    // Second program header p_type (offset 0x40 + 56).
    let second_offset = 0x40 + 56;
    bytes[second_offset..second_offset + 4].copy_from_slice(&2u32.to_le_bytes());
    let err = parse_elf64_riscv(&bytes).expect_err("non-PT_LOAD rejected");
    assert!(matches!(err, Error::Unsupported(_)));
}
