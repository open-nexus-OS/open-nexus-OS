use nexus_loader::{load_with, parse_elf64_riscv, Error, Mapper, Prot, SegmentPlan};

struct RecordingMapper {
    segments: Vec<(SegmentPlan, Vec<u8>)>,
}

impl RecordingMapper {
    fn new() -> Self {
        Self { segments: Vec::new() }
    }
}

impl Mapper for RecordingMapper {
    fn map_segment(&mut self, seg: &SegmentPlan, src: &[u8]) -> Result<(), Error> {
        self.segments.push((seg.clone(), src.to_vec()));
        Ok(())
    }
}

fn fixture() -> &'static [u8] {
    const BYTES: &[u8] = &[
        0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xf3, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x01, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
        0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x17, 0x05, 0x00, 0x00, 0x13, 0x05, 0x85, 0x05,
        0x83, 0x45, 0x05, 0x00, 0x63, 0x88, 0x05, 0x00, 0xef, 0x00, 0x80, 0x02,
        0x13, 0x05, 0x15, 0x00, 0x6f, 0xf0, 0x1f, 0xff, 0x93, 0x05, 0xd0, 0x00,
        0xef, 0x00, 0x80, 0x01, 0x93, 0x05, 0xa0, 0x00, 0xef, 0x00, 0x00, 0x01,
        0x93, 0x08, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00, 0x6f, 0xf0, 0x9f, 0xff,
        0xb7, 0x02, 0x00, 0x10, 0x93, 0x82, 0x52, 0x00, 0x03, 0xc3, 0x02, 0x00,
        0x13, 0x73, 0x03, 0x02, 0xe3, 0x0c, 0x03, 0xfe, 0xb7, 0x03, 0x00, 0x10,
        0x23, 0x80, 0xb3, 0x00, 0x67, 0x80, 0x00, 0x00, 0x63, 0x68, 0x69, 0x6c,
        0x64, 0x3a, 0x20, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2d, 0x65, 0x6c, 0x66,
        0x00,
    ];
    BYTES
}

#[test]
fn parse_fixture_segments_are_sorted() {
    let plan = parse_elf64_riscv(fixture()).expect("parse fixture");
    assert_eq!(plan.entry, 0x10000);
    assert_eq!(plan.segments.len(), 2);
    assert!(plan.segments[0].vaddr < plan.segments[1].vaddr);
    assert_eq!(plan.segments[0].prot, Prot::R | Prot::X);
    assert_eq!(plan.segments[1].prot, Prot::R | Prot::W);
}

#[test]
fn load_with_invokes_mapper_in_order() {
    let mut mapper = RecordingMapper::new();
    let plan = load_with(fixture(), &mut mapper).expect("load fixture");
    assert_eq!(mapper.segments.len(), plan.segments.len());
    let recorded_vaddrs: Vec<u64> = mapper.segments.iter().map(|(seg, _)| seg.vaddr).collect();
    let planned_vaddrs: Vec<u64> = plan.segments.iter().map(|seg| seg.vaddr).collect();
    assert_eq!(recorded_vaddrs, planned_vaddrs);
}

#[test]
fn rejects_write_execute_segments() {
    let mut bytes = fixture().to_vec();
    // Set PF_W | PF_X on the first program header
    let flags_offset = 68; // first program header flags
    let flags = u32::from_le_bytes(bytes[flags_offset..flags_offset + 4].try_into().unwrap());
    let new_flags = flags | 0b011;
    bytes[flags_offset..flags_offset + 4].copy_from_slice(&new_flags.to_le_bytes());
    let err = parse_elf64_riscv(&bytes).expect_err("should reject WX");
    assert_eq!(err, Error::ProtWx);
}
