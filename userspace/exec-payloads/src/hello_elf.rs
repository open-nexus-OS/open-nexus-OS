//! CONTEXT: Embedded ELF64/RISC-V payload for testing and bootstrap
//!
//! OWNERS: @runtime
//!
//! PUBLIC API:
//!   - HELLO_ELF: Embedded RISC-V ELF binary (409 bytes)
//!   - HELLO_MANIFEST_NXB: Canonical manifest.nxb bytes for the demo bundle (Cap'n Proto)
//!   - HELLO_MANIFEST_TOML: TOML manifest template (tooling input only)
//!
//! EMBEDDED DATA:
//!   - ELF binary: RISC-V executable that prints "child: hello-elf" and yields
//!   - NXB manifest: Deterministic Cap'n Proto binary (on-disk contract)
//!   - TOML manifest: Human-editable input template (not an on-disk contract)
//!
//! SECURITY INVARIANTS:
//!   - No unsafe code in embedded data
//!   - ELF binary is statically validated
//!   - Manifest data is properly formatted
//!   - No external dependencies on binary assets
//!
//! ERROR CONDITIONS:
//!   - Invalid ELF format: Binary will fail to load
//!   - Malformed manifest: NXB/TOML parsing will fail
//!   - Size limits: ELF binary is fixed at 409 bytes
//!
//! DEPENDENCIES:
//!   - None (embedded data only)
//!
//! FEATURES:
//!   - Embedded ELF binary for testing
//!   - NXB manifest for bundle metadata
//!   - TOML manifest template for selftests
//!   - No external binary dependencies
//!
//! TEST SCENARIOS:
//!   - test_elf_parsing(): Parse embedded ELF binary
//!   - test_manifest_validation(): Validate manifest.nxb format
//!   - test_toml_template(): Validate TOML manifest template
//!   - test_bundle_creation(): Create bundle from embedded data
//!   - test_loader_integration(): Load ELF using nexus-loader
//!   - test_execution(): Execute ELF and verify output
//!   - test_manifest_roundtrip(): Round-trip manifest serialization
//!
//! ADR: docs/adr/0007-executable-payloads-architecture.md

/// Embedded RISC-V ELF payload that prints a marker and yields forever.
///
/// The bytes are stored directly in this module to avoid relying on external
/// binary assets, keeping the repository friendly to tooling that rejects
/// non-text artefacts.
#[rustfmt::skip]
const HELLO_ELF_BYTES: [u8; 409] = [
    0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xf3, 0x00, 0x01, 0x00, 0x00, 0x00,
    // Entry point: 0x10130 (matches PT_LOAD vaddr and points at the first instruction).
    0x30, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
    // PT_LOAD offset: 0x130 (aligned with vaddr's low 12 bits per ELF rules).
    0x30, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // PT_LOAD vaddr/paddr: 0x10130
    0x30, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x30, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    // Payload @ file offset 0x130 (vaddr 0x10130): prints "child: hello-elf" via debug_putc syscalls.
    // IMPORTANT: keep the message pointer in s0 (callee-saved). The kernel trap path
    // intentionally uses/clobbers t-registers for scratch while handling syscalls.
    0x17, 0x04, 0x00, 0x00, 0x13, 0x04, 0xc4, 0x02, 0x03, 0x45, 0x04, 0x00,
    0x63, 0x0a, 0x05, 0x00, 0x93, 0x08, 0x00, 0x01, 0x73, 0x00, 0x00, 0x00,
    0x13, 0x04, 0x14, 0x00, 0x6f, 0xf0, 0xdf, 0xfe, 0x93, 0x08, 0x00, 0x00,
    0x73, 0x00, 0x00, 0x00, 0x6f, 0xf0, 0x9f, 0xff,
    // "child: hello-elf\n\0"
    0x63, 0x68, 0x69, 0x6c, 0x64, 0x3a, 0x20, 0x68, 0x65, 0x6c, 0x6c, 0x6f,
    0x2d, 0x65, 0x6c, 0x66, 0x0a, 0x00,
    // Pad the remainder of the PT_LOAD segment (filesz=0x69).
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

/// Byte slice view over the embedded ELF payload packaged in `demo.hello.nxb`.
pub static HELLO_ELF: &[u8] = &HELLO_ELF_BYTES;

/// Canonical manifest bytes shipped alongside the demo bundle as `manifest.nxb`.
///
/// Generated at build time by `build.rs` to avoid committing binary artifacts.
pub static HELLO_MANIFEST_NXB: &[u8] =
    include_bytes!(concat!(env!("OUT_DIR"), "/hello.manifest.nxb"));

/// Canonical manifest bytes shipped alongside the demo exit bundle as `manifest.nxb`.
///
/// Generated at build time by `build.rs` to avoid committing binary artifacts.
pub static EXIT0_MANIFEST_NXB: &[u8] =
    include_bytes!(concat!(env!("OUT_DIR"), "/exit0.manifest.nxb"));

/// TOML manifest template (tooling input only; not an on-disk contract).
pub const HELLO_MANIFEST_TOML: &str = r#"name = \"demo.hello\"
version = \"0.0.1\"
abilities = [\"demo\"]
caps = []
min_sdk = \"0.1.0\"
publisher = \"0123456789abcdef0123456789abcdef\"
sig = \"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
1111111\""#;
