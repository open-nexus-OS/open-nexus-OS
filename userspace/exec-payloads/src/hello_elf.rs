//! CONTEXT: Embedded ELF64/RISC-V payload for testing and bootstrap
//!
//! OWNERS: @runtime
//!
//! PUBLIC API:
//!   - HELLO_ELF: Embedded RISC-V ELF binary (409 bytes)
//!   - HELLO_MANIFEST: JSON manifest for the demo bundle
//!   - HELLO_MANIFEST_TOML: TOML manifest template for selftests
//!
//! EMBEDDED DATA:
//!   - ELF binary: RISC-V executable that prints "child: hello-elf" and yields
//!   - JSON manifest: Bundle metadata with name, version, capabilities
//!   - TOML manifest: Template for selftest staging and installation
//!
//! SECURITY INVARIANTS:
//!   - No unsafe code in embedded data
//!   - ELF binary is statically validated
//!   - Manifest data is properly formatted
//!   - No external dependencies on binary assets
//!
//! ERROR CONDITIONS:
//!   - Invalid ELF format: Binary will fail to load
//!   - Malformed manifest: JSON/TOML parsing will fail
//!   - Size limits: ELF binary is fixed at 409 bytes
//!
//! DEPENDENCIES:
//!   - None (embedded data only)
//!
//! FEATURES:
//!   - Embedded ELF binary for testing
//!   - JSON manifest for bundle metadata
//!   - TOML manifest template for selftests
//!   - No external binary dependencies
//!
//! TEST SCENARIOS:
//!   - test_elf_parsing(): Parse embedded ELF binary
//!   - test_manifest_validation(): Validate JSON manifest format
//!   - test_toml_template(): Validate TOML manifest template
//!   - test_bundle_creation(): Create bundle from embedded data
//!   - test_loader_integration(): Load ELF using nexus-loader
//!   - test_execution(): Execute ELF and verify output
//!   - test_manifest_roundtrip(): Round-trip manifest serialization
//!
//! ADR: docs/adr/0007-executable-payloads-architecture.md

/// Embedded RISC-V ELF payload that prints a marker and yields forever.
///
/// The bytes are stored directly in this module to avoid relying on external
/// binary assets, keeping the repository friendly to tooling that rejects
/// non-text artefacts.
#[rustfmt::skip]
const HELLO_ELF_BYTES: [u8; 409] = [
    0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xf3, 0x00, 0x01, 0x00, 0x00, 0x00,
    // Entry point: 0x10130 (matches PT_LOAD vaddr and points at the first instruction).
    0x30, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
    // PT_LOAD offset: 0x130 (aligned with vaddr's low 12 bits per ELF rules).
    0x30, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // PT_LOAD vaddr/paddr: 0x10130
    0x30, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x30, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x69, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    // Payload @ file offset 0x130 (vaddr 0x10130): prints "child: hello-elf" via debug_putc syscalls.
    // IMPORTANT: keep the message pointer in s0 (callee-saved). The kernel trap path
    // intentionally uses/clobbers t-registers for scratch while handling syscalls.
    0x17, 0x04, 0x00, 0x00, 0x13, 0x04, 0xc4, 0x02, 0x03, 0x45, 0x04, 0x00,
    0x63, 0x0a, 0x05, 0x00, 0x93, 0x08, 0x00, 0x01, 0x73, 0x00, 0x00, 0x00,
    0x13, 0x04, 0x14, 0x00, 0x6f, 0xf0, 0xdf, 0xfe, 0x93, 0x08, 0x00, 0x00,
    0x73, 0x00, 0x00, 0x00, 0x6f, 0xf0, 0x9f, 0xff,
    // "child: hello-elf\n\0"
    0x63, 0x68, 0x69, 0x6c, 0x64, 0x3a, 0x20, 0x68, 0x65, 0x6c, 0x6c, 0x6f,
    0x2d, 0x65, 0x6c, 0x66, 0x0a, 0x00,
    // Pad the remainder of the PT_LOAD segment (filesz=0x69).
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

/// Byte slice view over the embedded ELF payload packaged in `demo.hello.nxb`.
pub static HELLO_ELF: &[u8] = &HELLO_ELF_BYTES;

/// Canonical manifest shipped alongside the demo bundle as JSON.
pub const HELLO_MANIFEST: &[u8] = br#"{\"name\":\"demo.hello\",\"version\":\"0.0.1\",\"required_caps\":[],\"publisher\":\"dev\",\"sig\":\"\"}"#;

/// TOML manifest template used by selftests when staging installs.
pub const HELLO_MANIFEST_TOML: &str = r#"name = \"demo.hello\"
version = \"0.0.1\"
abilities = [\"demo\"]
caps = []
min_sdk = \"0.1.0\"
publisher = \"0123456789abcdef0123456789abcdef\"
sig = \"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111
1111111\""#;
